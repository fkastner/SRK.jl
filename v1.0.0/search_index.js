var documenterSearchIndex = {"docs":
[{"location":"functions/#Function-reference","page":"Index","title":"Function reference","text":"","category":"section"},{"location":"functions/","page":"Index","title":"Index","text":"DocTestSetup = :(using LinearAlgebra; using LevyArea)","category":"page"},{"location":"functions/#Main-Functions","page":"Index","title":"Main Functions","text":"","category":"section"},{"location":"functions/","page":"Index","title":"Index","text":"iterated_integrals\nLevyArea.levyarea\nLevyArea.AbstractIteratedIntegralAlgorithm\nLevyArea.AbstractErrorNorm\noptimal_algorithm","category":"page"},{"location":"functions/#LevyArea.iterated_integrals","page":"Index","title":"LevyArea.iterated_integrals","text":"iterated_integrals(W::AbstractVector, h, eps=h^(3/2);\n    ito_correction=true,\n    error_norm=MaxL2(),\n    alg=optimal_algorithm(length(W),h,eps,error_norm)\n)\n\nSimulates an approximation of the iterated stochastic integrals int_0^hint_0^sdW_i(t)dW_j(s) for all pairs 1le i j le m of the given m-dimensional Brownian motion with step size h.\n\nExamples\n\njulia> h = 1/2;\n\njulia> W = [1.0, 0.5]\n2-element Vector{Float64}:\n 1.0\n 0.5\n\njulia> diag(iterated_integrals(W, h, h^(3/2))) ≈ 0.5*W.^2 .- 0.5h\ntrue\n\n\n\n\n\niterated_integrals(W::AbstractVector, q_12::AbstractVector, h, eps; \n    ito_correction=true,\n    error_norm=FrobeniusL2(),\n    alg=optimal_algorithm(length(W),q_12,h,eps,error_norm)\n)\n\nSimulates an approximation of the iterated stochastic integrals for finite-dimensional approximations of a Q-Wiener process with covariance matrix Q = Q^frac12*Q^frac12. Here q_12 is a vector of the eigenvalues of Q^frac12; the square root of the covariance matrix. Equivalently these are the square roots of the eigenvalues of Q.\n\nExamples\n\njulia> h = 0.01; dim=10; q = [1/k^2 for k=1:dim];\n\njulia> W = √h * sqrt.(q) .* randn(dim);\n\njulia> diag(iterated_integrals(W,sqrt.(q),h,h^(3/2))) ≈ 0.5*W.^2 .- 0.5*h*q\ntrue\n\n\n\n\n\niterated_integrals(W::Real, h::Real, eps::Real=0.0; ito_correction=true, kwargs...)\n\nIn the case of a scalar Brownian motion the integral can be explicitly calculated as int_0^hint_0^sdW(t)dW(s) = frac12W(h)^2 - frac12h.\n\nThe parameter eps (as well as all additional keyword arguments) has no effect but is available  to provide the same interface as the multidimensional version.\n\n\n\n\n\niterated_integrals(W::Real, q_12::Real, h::Real, eps::Real; ito_correction=true, kwargs...)\n\nIn the case of a scalar Q-Wiener process with (scalar) covariance Q the integral can be explicitly calculated as int_0^hint_0^sdW(t)dW(s) = frac12W(h)^2 - frac12hQ.\n\nNote that, as in the multidimensional case, the parameter q_12 denotes the square root of the covariance.\n\nThe parameter eps (as well as all additional keyword arguments) has no effect but is available  to provide the same interface as the multidimensional version.\n\n\n\n\n\n","category":"function"},{"location":"functions/#LevyArea.levyarea","page":"Index","title":"LevyArea.levyarea","text":"levyarea(W, n, alg::Fourier)\n\nSimulates an approximation of the iterated Itô-integrals int_0^1W_sotimes dW_s of the given m-dimensional increment of a Wiener process with step size 1. The parameter n specifies the number of terms in the approximation and thus determines the accuracy. This algorithm is based on a Fourier expansion of the Wiener process. The algorithm needs approximately m^2+2cdot mcdot n Float's and 2cdot mcdot n random numbers. The time complexity is mathcalO(m^2cdot n).\n\n\n\n\n\nlevyarea(W, n, alg::Milstein)\n\nSimulates an approximation of the iterated Itô-integrals int_0^1W_sotimes dW_s of the given m-dimensional increment of a Wiener process with step size 1. The parameter n specifies the number of terms in the approximation and thus determines the accuracy. This is an efficient implementation of the algorithm proposed in Milstein, 1994. It is based on a Fourier expansion of the Wiener process. The algorithm needs approximately m^2+2cdot mcdot n Float's. The time complexity is mathcalO(m^2cdot n).\n\n\n\n\n\nlevyarea(W, n, alg::Wiktorsson)\n\nSimulates an approximation of the iterated Itô-integrals int_0^1W_sotimes dW_s of the given m-dimensional increment of a Wiener process with step size 1. The parameter n specifies the number of terms in the approximation and thus determines the accuracy. This is an efficient implementation of the algorithm proposed in Wiktorsson, 2001. It is based on the Fourier method from Milstein but incorporates an additional tail sum approximation. The algorithm needs approximately 2cdot m^2+2cdot mcdot n+m Float's. The time complexity is mathcalO(m^2cdot n).\n\n\n\n\n\nlevyarea(W, n, alg::MronRoe)\n\nSimulates an approximation of the iterated Itô-integrals int_0^1W_sotimes dW_s of the given m-dimensional increment of a Wiener process with step size 1. The parameter n specifies the number of terms in the approximation and thus determines the accuracy. This is an efficient implementation of the algorithm proposed in Mrongowius & Rößler, 2021. It is based on the Fourier method from Milstein but incorporates an improved tail sum approximation. The algorithm needs approximately m^2+2cdot mcdot n Float's  and 12m^2+2cdot mcdot n + 12m random numbers. The time complexity is mathcalO(m^2cdot n).\n\n\n\n\n\n","category":"function"},{"location":"functions/#LevyArea.AbstractIteratedIntegralAlgorithm","page":"Index","title":"LevyArea.AbstractIteratedIntegralAlgorithm","text":"abstract type AbstractIteratedIntegralAlgorithm end\n\nAbstract type for algorithms for the simulation of iterated integrals.\n\njulia> subtypes(AbstractIteratedIntegralAlgorithm)\n4-element Vector{Any}:\n Fourier\n Milstein\n MronRoe\n Wiktorsson\n\n\n\n\n\n","category":"type"},{"location":"functions/#LevyArea.AbstractErrorNorm","page":"Index","title":"LevyArea.AbstractErrorNorm","text":"abstract type AbstractErrorNorm end\n\nAbstract type for different kind of errors one might consider. The most important are MaxL2 and FrobeniusL2. These are actually special cases of the MaxLp{p} and SchattenqLp{p,q} norms:\n\nconst MaxL2 = MaxLp{2}\nconst FrobeniusL2 = SchattenqLp{2,2}\n\nAll currently defined norms:\n\njulia> subtypes(LevyArea.AbstractErrorNorm)\n3-element Vector{Any}:\n LevyArea.LpMax\n LevyArea.MaxLp\n LevyArea.SchattenqLp\n\n\n\n\n\n","category":"type"},{"location":"functions/#LevyArea.optimal_algorithm","page":"Index","title":"LevyArea.optimal_algorithm","text":"optimal_algorithm(dim, stepsize, eps=stepsize^(3/2), norm=MaxL2())\noptimal_algorithm(dim, q_12, stepsize, eps, norm=FrobeniusL2())\n\nReturns the optimal algorithm for the given parameters, i.e. the algorithm that needs to simulate the fewest random numbers to achieve the desired precision eps.\n\nExamples\n\njulia> h = 1/128;\n\njulia> optimal_algorithm(10, h, h^(3/2), MaxL2())\nMronRoe()\n\njulia> optimal_algorithm(10, 1.0./(1:10).^2, h, h^(3/2), FrobeniusL2())\nMilstein()\n\n\n\n\n\n","category":"function"},{"location":"functions/#Algorithmic-properties","page":"Index","title":"Algorithmic properties","text":"","category":"section"},{"location":"functions/","page":"Index","title":"Index","text":"terms_needed\nLevyArea.convorder\nLevyArea.errcoeff\nLevyArea.norv\nLevyArea.effective_cost","category":"page"},{"location":"functions/#LevyArea.terms_needed","page":"Index","title":"LevyArea.terms_needed","text":"terms_needed(dim, stepsize, eps, alg, norm)\n\nReturns the number of terms in the approximating sum that is needed to ensure an error in the given norm of at most eps. This depends on the dimension of the Wiener process dim, the current stepsize and the chosen algorithm.\n\nSee also: AbstractIteratedIntegralAlgorithm, AbstractErrorNorm\n\nExamples\n\njulia> h = 1/128;\n\njulia> terms_needed(10, h, h^(3/2), Milstein(), MaxL2())\n7\n\nImplementation\n\nNew algorithms should only have to implement errcoeff and convorder.\n\n\n\n\n\nterms_needed(dim, q_12, stepsize, eps, alg, norm)\n\nUsed for finite-dimensional approximations of a Q-Wiener process with covariance matrix Q = Q^frac12*Q^frac12. Here q_12 is a vector of the eigenvalues of Q^frac12; the square root of the covariance matrix. Equivalently these are the square roots of the eigenvalues of Q.\n\nExamples\n\njulia> h = 1/128;\n\njulia> dim = 10;\n\njulia> q = [1/k^2 for k=1:dim];\n\njulia> terms_needed(dim, sqrt.(q), h, h^(3/2), Milstein(), FrobeniusL2())\n9\n\n\n\n\n\n","category":"function"},{"location":"functions/#LevyArea.convorder","page":"Index","title":"LevyArea.convorder","text":"convorder(alg::AbstractIteratedIntegralAlgorithm)\n\nReturns the convergence order of the algorithm w.r.t. the truncation parameter.\n\nSee also: errcoeff\n\n\n\n\n\n","category":"function"},{"location":"functions/#LevyArea.errcoeff","page":"Index","title":"LevyArea.errcoeff","text":"errcoeff(dim, stepsize, alg, norm)\nerrcoeff(dim, q_12, stepsize, alg, norm)\n\nReturns the coefficient of the truncation parameter in the error estimate. I.e. the error estimate is of the form\n\nlVert I(h)-tildeI^(p)(h) rVert_*  mathrmerrcoeff(mh) cdot p^-γ\n\nwhere the norm is given by norm, the approximation tildeI^(p) is  calculated using alg and γ is the order of convergence given by convorder(alg).\n\n\n\n\n\n","category":"function"},{"location":"functions/#LevyArea.norv","page":"Index","title":"LevyArea.norv","text":"norv(dim, n, alg::AbstractIteratedIntegralAlgorithm)\n\nReturns the number of random numbers needed to simulate the iterated integrals for a Wiener process of dimension dim and with truncation parameter n.\n\n\n\n\n\n","category":"function"},{"location":"functions/#LevyArea.effective_cost","page":"Index","title":"LevyArea.effective_cost","text":"effective_cost(dim, stepsize, eps, alg, norm)\neffective_cost(dim, q_12, stepsize, eps, alg, norm)\n\nReturns the number of random numbers needed to simulate the iterated integrals with the given parameters.\n\n\n\n\n\n","category":"function"},{"location":"functions/#Helper-functions","page":"Index","title":"Helper functions","text":"","category":"section"},{"location":"functions/","page":"Index","title":"Index","text":"LevyArea.ito_correction!","category":"page"},{"location":"functions/#LevyArea.ito_correction!","page":"Index","title":"LevyArea.ito_correction!","text":"ito_correction!(I, h=1)\n\nApplies the Itô-correction for iterated integrals to I. This amounts to subtracting frac12h from every element on the diagonal.\n\nExample\n\njulia> M = ones(5,5);\n\njulia> LevyArea.ito_correction!(M, 0.5)\n\n\njulia> M\n5×5 Matrix{Float64}:\n 0.75  1.0   1.0   1.0   1.0\n 1.0   0.75  1.0   1.0   1.0\n 1.0   1.0   0.75  1.0   1.0\n 1.0   1.0   1.0   0.75  1.0\n 1.0   1.0   1.0   1.0   0.75\n\n\n\n\n\n","category":"function"},{"location":"functions/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"functions/","page":"Index","title":"Index","text":"","category":"page"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/#milstein1994","page":"References","title":"Milstein, 1994","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Milstein, G. N., \"Numerical integration of stochastic differential equations.\"Vol. 313. Springer Science & Business Media, 1995. DOI: 10.1007/978-94-015-8455-5.","category":"page"},{"location":"references/#mr2021","page":"References","title":"Mrongowius & Rößler, 2021","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Mrongowius, J. and Rößler, A., \"On the Approximation and Simulation of Iterated Stochastic Integrals and the Corresponding Lévy Areas in Terms of a Multidimensional Brownian Motion.\"Stochastic Analysis and Applications (2021), pp. 1–29. arXiv: 2101.09542. DOI: 10.1080/07362994.2021.1922291.","category":"page"},{"location":"references/#wiktorsson2001","page":"References","title":"Wiktorsson, 2001","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"Wiktorsson, M., \"Joint Characteristic Function and Simultaneous Simulation of Iterated Itô Integrals for Multiple Independent Brownian Motions.\"The Annals of Applied Probability 11.2 (2001), pp. 470-487. DOI: 10.1214/aoap/1015345301.","category":"page"},{"location":"#LevyArea.jl","page":"Home","title":"LevyArea.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Iterated Stochastic Integrals in Julia","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package implements state-of-the-art methods for the simulation of iterated stochastic integrals. These appear e.g. in higher order algorithms for the solution of stochastic (partial) differential equations.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package can be installed from the Julia package manager (type ])","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add LevyArea","category":"page"},{"location":"#Usage-Example","page":"Home","title":"Usage Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Load the package and generate a Wiener increment:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using LevyArea\njulia> m = 5; # dimension of Wiener process\njulia> h = 0.01; # step size or length of time interval\njulia> err = 0.05; # error bound\njulia> W = sqrt(h) * randn(m); # increment of Wiener process","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here, W is the m-dimensional vector of increments of the driving Wiener process on some time interval of length h.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The default call uses h^(3/2) as the precision and chooses the best algorithm automatically:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> II = iterated_integrals(W,h)","category":"page"},{"location":"","page":"Home","title":"Home","text":"If not stated otherwise, the default error criterion is the maxL^2-error and the function returns the m times m matrix II containing a realisation of the approximate iterated stochastic integrals that correspond to the given increment W.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The desired precision can be optionally provided using a third positional argument:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> II = iterated_integrals(W,h,err)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Again, the software package automatically chooses the optimal algorithm.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To determine which algorithm is chosen by the package without simulating any iterated stochastic integrals yet, the function optimal_algorithm can be used. The arguments to this function are the dimension of the Wiener process, the step size and the desired precision:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> alg = optimal_algorithm(m,h,err); # output: Fourier()","category":"page"},{"location":"","page":"Home","title":"Home","text":"It is also possible to choose the algorithm directly using the keyword argument alg. The value can be one of Fourier(), Milstein(), Wiktorsson() and MronRoe():","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> II = iterated_integrals(W,h; alg=Milstein())","category":"page"},{"location":"","page":"Home","title":"Home","text":"As the norm for the considered error, e.g., the maxL^2- and mathrmFL^2-norm can be selected using a keyword argument. The corresponding values are MaxL2() and FrobeniusL2():","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> II = iterated_integrals(W,h,err; error_norm=FrobeniusL2())","category":"page"},{"location":"","page":"Home","title":"Home","text":"If iterated stochastic integrals for some Q-Wiener process need to be simulated, like for the numerical simulation of solutions to SPDEs, then the increment of the Q-Wiener process together with the square roots of the eigenvalues of the associated covariance operator have to be provided:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> q = [1/k^2 for k=1:m]; # eigenvalues of cov. operator\njulia> QW = sqrt(h) * sqrt.(q) .* randn(m); # Q-Wiener increment\njulia> IIQ = iterated_integrals(QW,sqrt.(q),h,err)","category":"page"},{"location":"","page":"Home","title":"Home","text":"In this case, the function iterated_integrals utilizes a scaling of the iterated stochastic integrals and also adjusts the error estimates appropriately such that the error bound holds w.r.t.\\ the iterated stochastic integrals mathcalI^Q(h) based on the Q-Wiener process. Here the error norm defaults to the mathrmFL^2-error.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that all discussed keyword arguments are optional and can be combined as needed. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Additional information can be found, e.g., using the Julia help mode:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ?iterated_integrals\njulia> ?optimal_algorithm","category":"page"},{"location":"#Related-Packages","page":"Home","title":"Related Packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Matlab version of this package is also available under LevyArea.m.","category":"page"}]
}
