<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Index · IteratedIntegrals.jl</title><link rel="canonical" href="https://fkastner.github.io/IteratedIntegrals.jl/functions/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">IteratedIntegrals.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Index</a><ul class="internal"><li><a class="tocitem" href="#Main-Functions"><span>Main Functions</span></a></li><li><a class="tocitem" href="#Algorithmic-properties"><span>Algorithmic properties</span></a></li><li><a class="tocitem" href="#Helper-functions"><span>Helper functions</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Index</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Index</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/fkastner/IteratedIntegrals.jl/blob/master/docs/src/functions.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Function-reference"><a class="docs-heading-anchor" href="#Function-reference">Function reference</a><a id="Function-reference-1"></a><a class="docs-heading-anchor-permalink" href="#Function-reference" title="Permalink"></a></h1><h2 id="Main-Functions"><a class="docs-heading-anchor" href="#Main-Functions">Main Functions</a><a id="Main-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Main-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="IteratedIntegrals.simiterintegrals" href="#IteratedIntegrals.simiterintegrals"><code>IteratedIntegrals.simiterintegrals</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">simiterintegrals(W::AbstractVector, h, eps=h^(3/2);
    ito_correction=true,
    error_norm=MaxL2(),
    alg=optimal_algorithm(length(W),h,eps,error_norm)
)</code></pre><p>Simulates an approximation of the iterated stochastic integrals <span>$\int_0^h\int_0^sdW_i(t)dW_j(s)$</span> for all pairs <span>$1\le i, j \le m$</span> of the given <span>$m$</span>-dimensional Brownian motion with step size h.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; h = 1/2;

julia&gt; W = [1.0, 0.5]
2-element Vector{Float64}:
 1.0
 0.5

julia&gt; diag(simiterintegrals(W, h, h^(3/2))) ≈ 0.5*W.^2 .- 0.5h
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fkastner/IteratedIntegrals.jl/blob/fb048a3404fb1e9e5b3b7cee74a32d75bc719b2f/src/simiterintegrals.jl#LL32-L55">source</a></section><section><div><pre><code class="language-none">simiterintegrals(W::AbstractVector, q_12::AbstractVector, h, eps; 
    ito_correction=true,
    error_norm=FrobeniusL2(),
    alg=optimal_algorithm(length(W),q_12,h,eps,error_norm)
)</code></pre><p>Simulates an approximation of the iterated stochastic integrals for finite-dimensional approximations of a Q-Wiener process with covariance matrix <span>$Q = Q^\frac{1}{2}*Q^\frac{1}{2}$</span>. Here <code>q_12</code> is a vector of the eigenvalues of <span>$Q^\frac{1}{2}$</span>; the square root of the covariance matrix. Equivalently these are the square roots of the eigenvalues of <span>$Q$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; h = 0.01; dim=10; q = [1/k^2 for k=1:dim];

julia&gt; W = √h * sqrt.(q) .* randn(dim);

julia&gt; diag(simiterintegrals(W,sqrt.(q),h,h^(3/2))) ≈ 0.5*W.^2 .- 0.5*h*q
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fkastner/IteratedIntegrals.jl/blob/fb048a3404fb1e9e5b3b7cee74a32d75bc719b2f/src/simiterintegrals.jl#LL71-L92">source</a></section><section><div><pre><code class="language-none">simiterintegrals(W::Real, h::Real, eps::Real=0.0; ito_correction=true, kwargs...)</code></pre><p>In the case of a scalar Brownian motion the integral can be explicitly calculated as <span>$\int_0^h\int_0^sdW(t)dW(s) = \frac{1}{2}W(h)^2 - \frac{1}{2}h$</span>.</p><p>The parameter <code>eps</code> (as well as all additional keyword arguments) has no effect but is available  to provide the same interface as the multidimensional version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fkastner/IteratedIntegrals.jl/blob/fb048a3404fb1e9e5b3b7cee74a32d75bc719b2f/src/simiterintegrals.jl#LL108-L116">source</a></section><section><div><pre><code class="language-none">simiterintegrals(W::Real, q_12::Real, h::Real, eps::Real; ito_correction=true, kwargs...)</code></pre><p>In the case of a scalar Q-Wiener process with (scalar) covariance Q the integral can be explicitly calculated as <span>$\int_0^h\int_0^sdW(t)dW(s) = \frac{1}{2}W(h)^2 - \frac{1}{2}hQ$</span>.</p><p>Note that, as in the multidimensional case, the parameter <code>q_12</code> denotes the square root of the covariance.</p><p>The parameter <code>eps</code> (as well as all additional keyword arguments) has no effect but is available  to provide the same interface as the multidimensional version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fkastner/IteratedIntegrals.jl/blob/fb048a3404fb1e9e5b3b7cee74a32d75bc719b2f/src/simiterintegrals.jl#LL119-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IteratedIntegrals.levyarea" href="#IteratedIntegrals.levyarea"><code>IteratedIntegrals.levyarea</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">levyarea(W, n, alg::Fourier)</code></pre><p>Simulates an approximation of the iterated Itô-integrals <span>$\int_0^1W_s\otimes dW_s$</span> of the given <span>$m$</span>-dimensional increment of a Wiener process with step size 1. The parameter <span>$n$</span> specifies the number of terms in the approximation and thus determines the accuracy. This algorithm is based on a Fourier expansion of the Wiener process. The algorithm needs approximately <span>$m^2+2\cdot m\cdot n$</span> Float&#39;s and <span>$2\cdot m\cdot n$</span> random numbers. The time complexity is <span>$\mathcal{O}(m^2\cdot n)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fkastner/IteratedIntegrals.jl/blob/fb048a3404fb1e9e5b3b7cee74a32d75bc719b2f/src/fourier.jl#LL10-L20">source</a></section><section><div><pre><code class="language-none">levyarea(W, n, alg::Milstein)</code></pre><p>Simulates an approximation of the iterated Itô-integrals <span>$\int_0^1W_s\otimes dW_s$</span> of the given <span>$m$</span>-dimensional increment of a Wiener process with step size 1. The parameter <span>$n$</span> specifies the number of terms in the approximation and thus determines the accuracy. This is an efficient implementation of the algorithm proposed in <a href="../references/#milstein1994">Milstein, 1994</a>. It is based on a Fourier expansion of the Wiener process. The algorithm needs approximately <span>$m^2+2\cdot m\cdot n$</span> Float&#39;s. The time complexity is <span>$\mathcal{O}(m^2\cdot n)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fkastner/IteratedIntegrals.jl/blob/fb048a3404fb1e9e5b3b7cee74a32d75bc719b2f/src/milstein.jl#LL11-L21">source</a></section><section><div><pre><code class="language-none">levyarea(W, n, alg::Wiktorsson)</code></pre><p>Simulates an approximation of the iterated Itô-integrals <span>$\int_0^1W_s\otimes dW_s$</span> of the given <span>$m$</span>-dimensional increment of a Wiener process with step size 1. The parameter <span>$n$</span> specifies the number of terms in the approximation and thus determines the accuracy. This is an efficient implementation of the algorithm proposed in <a href="../references/#wiktorsson2001">Wiktorsson, 2001</a>. It is based on the Fourier method from Milstein but incorporates an additional tail sum approximation. The algorithm needs approximately <span>$2\cdot m^2+2\cdot m\cdot n+m$</span> Float&#39;s. The time complexity is <span>$\mathcal{O}(m^2\cdot n)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fkastner/IteratedIntegrals.jl/blob/fb048a3404fb1e9e5b3b7cee74a32d75bc719b2f/src/wiktorsson.jl#LL11-L21">source</a></section><section><div><pre><code class="language-none">levyarea(W, n, alg::MR)</code></pre><p>Simulates an approximation of the iterated Itô-integrals <span>$\int_0^1W_s\otimes dW_s$</span> of the given <span>$m$</span>-dimensional increment of a Wiener process with step size 1. The parameter <span>$n$</span> specifies the number of terms in the approximation and thus determines the accuracy. This is an efficient implementation of the algorithm proposed in <a href="../references/#mr2021">Mrongowius &amp; Rößler, 2021</a>. It is based on the Fourier method from Milstein but incorporates an improved tail sum approximation. The algorithm needs approximately <span>$m^2+2\cdot m\cdot n$</span> Float&#39;s  and <span>$1/2m^2+2\cdot m\cdot n + 1/2m$</span> random numbers. The time complexity is <span>$\mathcal{O}(m^2\cdot n)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fkastner/IteratedIntegrals.jl/blob/fb048a3404fb1e9e5b3b7cee74a32d75bc719b2f/src/mr.jl#LL11-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IteratedIntegrals.AbstractIteratedIntegralAlgorithm" href="#IteratedIntegrals.AbstractIteratedIntegralAlgorithm"><code>IteratedIntegrals.AbstractIteratedIntegralAlgorithm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractIteratedIntegralAlgorithm end</code></pre><p>Abstract type for algorithms for the simulation of iterated integrals.</p><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractIteratedIntegralAlgorithm)
4-element Vector{Any}:
 Fourier
 MR
 Milstein
 Wiktorsson</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fkastner/IteratedIntegrals.jl/blob/fb048a3404fb1e9e5b3b7cee74a32d75bc719b2f/src/IteratedIntegrals.jl#LL9-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IteratedIntegrals.AbstractErrorNorm" href="#IteratedIntegrals.AbstractErrorNorm"><code>IteratedIntegrals.AbstractErrorNorm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractErrorNorm end</code></pre><p>Abstract type for different kind of errors one might consider. The most important are <code>MaxL2</code> and <code>FrobeniusL2</code>. These are actually special cases of the <code>MaxLp{p}</code> and <code>SchattenqLp{p,q}</code> norms:</p><pre><code class="language-julia">const MaxL2 = MaxLp{2}
const FrobeniusL2 = SchattenqLp{2,2}</code></pre><p>All currently defined norms:</p><pre><code class="language-julia-repl">julia&gt; subtypes(IteratedIntegrals.AbstractErrorNorm)
3-element Vector{Any}:
 IteratedIntegrals.LpMax
 IteratedIntegrals.MaxLp
 IteratedIntegrals.SchattenqLp</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fkastner/IteratedIntegrals.jl/blob/fb048a3404fb1e9e5b3b7cee74a32d75bc719b2f/src/error_norms.jl#LL5-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IteratedIntegrals.optimal_algorithm" href="#IteratedIntegrals.optimal_algorithm"><code>IteratedIntegrals.optimal_algorithm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">optimal_algorithm(dim, stepsize, eps=stepsize^(3/2), norm=MaxL2())
optimal_algorithm(dim, q_12, stepsize, eps, norm=FrobeniusL2())</code></pre><p>Returns the optimal algorithm for the given parameters, i.e. the algorithm that needs to simulate the fewest random numbers to achieve the desired precision <code>eps</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; h = 1/128;

julia&gt; optimal_algorithm(10, h, h^(3/2), MaxL2())
MR()

julia&gt; optimal_algorithm(10, 1.0./(1:10).^2, h, h^(3/2), FrobeniusL2())
Milstein()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fkastner/IteratedIntegrals.jl/blob/fb048a3404fb1e9e5b3b7cee74a32d75bc719b2f/src/alg_utils.jl#LL97-L115">source</a></section></article><h2 id="Algorithmic-properties"><a class="docs-heading-anchor" href="#Algorithmic-properties">Algorithmic properties</a><a id="Algorithmic-properties-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithmic-properties" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="IteratedIntegrals.terms_needed" href="#IteratedIntegrals.terms_needed"><code>IteratedIntegrals.terms_needed</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">terms_needed(dim, stepsize, eps, alg, norm)</code></pre><p>Returns the number of terms in the approximating sum that is needed to ensure an error in the given norm of at most <code>eps</code>. This depends on the dimension of the Wiener process <code>dim</code>, the current stepsize and the chosen algorithm.</p><p>See also: <a href="#IteratedIntegrals.AbstractIteratedIntegralAlgorithm"><code>AbstractIteratedIntegralAlgorithm</code></a>, <a href="#IteratedIntegrals.AbstractErrorNorm"><code>AbstractErrorNorm</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; h = 1/128;

julia&gt; terms_needed(10, h, h^(3/2), Milstein(), MaxL2())
7</code></pre><p><strong>Implementation</strong></p><p>New algorithms should only have to implement <a href="#IteratedIntegrals.errcoeff"><code>errcoeff</code></a> and <a href="#IteratedIntegrals.convorder"><code>convorder</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fkastner/IteratedIntegrals.jl/blob/fb048a3404fb1e9e5b3b7cee74a32d75bc719b2f/src/alg_utils.jl#LL26-L45">source</a></section><section><div><pre><code class="language-none">terms_needed(dim, q_12, stepsize, eps, alg, norm)</code></pre><p>Used for finite-dimensional approximations of a Q-Wiener process with covariance matrix <span>$Q = Q^\frac{1}{2}*Q^\frac{1}{2}$</span>. Here <code>q_12</code> is a vector of the eigenvalues of <span>$Q^\frac{1}{2}$</span>; the square root of the covariance matrix. Equivalently these are the square roots of the eigenvalues of <span>$Q$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; h = 1/128;

julia&gt; dim = 10;

julia&gt; q = [1/k^2 for k=1:dim];

julia&gt; terms_needed(dim, sqrt.(q), h, h^(3/2), Milstein(), FrobeniusL2())
9</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fkastner/IteratedIntegrals.jl/blob/fb048a3404fb1e9e5b3b7cee74a32d75bc719b2f/src/alg_utils.jl#LL50-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IteratedIntegrals.convorder" href="#IteratedIntegrals.convorder"><code>IteratedIntegrals.convorder</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">convorder(alg::AbstractIteratedIntegralAlgorithm)</code></pre><p>Returns the convergence order of the algorithm w.r.t. the truncation parameter.</p><p>See also: <a href="#IteratedIntegrals.errcoeff"><code>errcoeff</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fkastner/IteratedIntegrals.jl/blob/fb048a3404fb1e9e5b3b7cee74a32d75bc719b2f/src/alg_utils.jl#LL1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IteratedIntegrals.errcoeff" href="#IteratedIntegrals.errcoeff"><code>IteratedIntegrals.errcoeff</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">errcoeff(dim, stepsize, alg, norm)
errcoeff(dim, q_12, stepsize, alg, norm)</code></pre><p>Returns the coefficient of the truncation parameter in the error estimate. I.e. the error estimate is of the form</p><p class="math-container">\[\lVert I(h)-\tilde{I}^{(p)}(h) \rVert_* ≤ \mathrm{errcoeff}(m,h) \cdot p^{-γ}\]</p><p>where the norm is given by <code>norm</code>, the approximation <span>$\tilde{I}^{(p)}$</span> is  calculated using <code>alg</code> and <span>$γ$</span> is the order of convergence given by <a href="#IteratedIntegrals.convorder"><code>convorder(alg)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fkastner/IteratedIntegrals.jl/blob/fb048a3404fb1e9e5b3b7cee74a32d75bc719b2f/src/alg_utils.jl#LL10-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IteratedIntegrals.norv" href="#IteratedIntegrals.norv"><code>IteratedIntegrals.norv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">norv(dim, n, alg::AbstractIteratedIntegralAlgorithm)</code></pre><p>Returns the number of random numbers needed to simulate the iterated integrals for a Wiener process of dimension <code>dim</code> and with truncation parameter <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fkastner/IteratedIntegrals.jl/blob/fb048a3404fb1e9e5b3b7cee74a32d75bc719b2f/src/alg_utils.jl#LL74-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="IteratedIntegrals.effective_cost" href="#IteratedIntegrals.effective_cost"><code>IteratedIntegrals.effective_cost</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">effective_cost(dim, stepsize, eps, alg, norm)
effective_cost(dim, q_12, stepsize, eps, alg, norm)</code></pre><p>Returns the number of random numbers needed to simulate the iterated integrals with the given parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fkastner/IteratedIntegrals.jl/blob/fb048a3404fb1e9e5b3b7cee74a32d75bc719b2f/src/alg_utils.jl#LL82-L88">source</a></section></article><h2 id="Helper-functions"><a class="docs-heading-anchor" href="#Helper-functions">Helper functions</a><a id="Helper-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Helper-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="IteratedIntegrals.ito_correction!" href="#IteratedIntegrals.ito_correction!"><code>IteratedIntegrals.ito_correction!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ito_correction!(I, h=1)</code></pre><p>Applies the Itô-correction for iterated integrals to <code>I</code>. This amounts to subtracting <span>$\frac{1}{2}h$</span> from every element on the diagonal.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; M = ones(5,5);

julia&gt; IteratedIntegrals.ito_correction!(M, 0.5)


julia&gt; M
5×5 Matrix{Float64}:
 0.75  1.0   1.0   1.0   1.0
 1.0   0.75  1.0   1.0   1.0
 1.0   1.0   0.75  1.0   1.0
 1.0   1.0   1.0   0.75  1.0
 1.0   1.0   1.0   1.0   0.75</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/fkastner/IteratedIntegrals.jl/blob/fb048a3404fb1e9e5b3b7cee74a32d75bc719b2f/src/simiterintegrals.jl#LL1-L23">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#IteratedIntegrals.AbstractErrorNorm"><code>IteratedIntegrals.AbstractErrorNorm</code></a></li><li><a href="#IteratedIntegrals.AbstractIteratedIntegralAlgorithm"><code>IteratedIntegrals.AbstractIteratedIntegralAlgorithm</code></a></li><li><a href="#IteratedIntegrals.convorder"><code>IteratedIntegrals.convorder</code></a></li><li><a href="#IteratedIntegrals.effective_cost"><code>IteratedIntegrals.effective_cost</code></a></li><li><a href="#IteratedIntegrals.errcoeff"><code>IteratedIntegrals.errcoeff</code></a></li><li><a href="#IteratedIntegrals.ito_correction!"><code>IteratedIntegrals.ito_correction!</code></a></li><li><a href="#IteratedIntegrals.levyarea"><code>IteratedIntegrals.levyarea</code></a></li><li><a href="#IteratedIntegrals.norv"><code>IteratedIntegrals.norv</code></a></li><li><a href="#IteratedIntegrals.optimal_algorithm"><code>IteratedIntegrals.optimal_algorithm</code></a></li><li><a href="#IteratedIntegrals.simiterintegrals"><code>IteratedIntegrals.simiterintegrals</code></a></li><li><a href="#IteratedIntegrals.terms_needed"><code>IteratedIntegrals.terms_needed</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../references/">References »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 30 November 2021 09:37">Tuesday 30 November 2021</span>. Using Julia version 1.6.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
